// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///
/// Copyright The Stargate Authors
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
/// http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The consistency level used to execute a request.
enum Stargate_Consistency: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case any // = 0
  case one // = 1
  case two // = 2
  case three // = 3
  case quorum // = 4
  case all // = 5
  case localQuorum // = 6
  case eachQuorum // = 7
  case serial // = 8
  case localSerial // = 9
  case localOne // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .any
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .any
    case 1: self = .one
    case 2: self = .two
    case 3: self = .three
    case 4: self = .quorum
    case 5: self = .all
    case 6: self = .localQuorum
    case 7: self = .eachQuorum
    case 8: self = .serial
    case 9: self = .localSerial
    case 10: self = .localOne
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .any: return 0
    case .one: return 1
    case .two: return 2
    case .three: return 3
    case .quorum: return 4
    case .all: return 5
    case .localQuorum: return 6
    case .eachQuorum: return 7
    case .serial: return 8
    case .localSerial: return 9
    case .localOne: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Stargate_Consistency] = [
    .any,
    .one,
    .two,
    .three,
    .quorum,
    .all,
    .localQuorum,
    .eachQuorum,
    .serial,
    .localSerial,
    .localOne,
  ]

}

/// A wrapper message for Consistency, for cases where the consistency level can be unset.
struct Stargate_ConsistencyValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Stargate_Consistency = .any

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A CQL value for a collection type.
/// For lists, sets and tuples, this contains the collection elements.
/// For maps, this contains the key and values in order (e.g. key1, value1, key2, value2...)
struct Stargate_Collection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elements: [Stargate_Value] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A value for a CQL user-defined type.
struct Stargate_UdtValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fields: Dictionary<String,Stargate_Value> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A 128-bit (16-byte) UUID type encoded using big-endian byte order. For example, the UUID
/// "00112233-4455-6677-8899-aabbccddeeff" would be store as the bytes:
/// | 0x00 0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88 0x99 0xAA 0xBB 0xCC 0xDD 0xEE 0xFF |
/// | MSB                                                                        LSB  |
struct Stargate_Uuid: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Either an IPv4 or IPv6 address stored as either 4 or 16 bytes, respectively. The addresses are
/// encoded using big-endian byte order.
struct Stargate_Inet: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stargate_Varint: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stargate_Decimal: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scale: UInt32 = 0

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A CQL value. This is used both in requests to bind parameterized query strings, and in responses
/// to represent the result data.
struct Stargate_Value: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inner: Stargate_Value.OneOf_Inner? = nil

  /// The CQL value NULL.
  var null: Stargate_Value.Null {
    get {
      if case .null(let v)? = inner {return v}
      return Stargate_Value.Null()
    }
    set {inner = .null(newValue)}
  }

  /// An unset value.
  /// This can only be used for bind values in requests.
  var unset: Stargate_Value.Unset {
    get {
      if case .unset(let v)? = inner {return v}
      return Stargate_Value.Unset()
    }
    set {inner = .unset(newValue)}
  }

  /// CQL types: tinyint, smallint, int, bigint, counter, timestamp
  var int: Int64 {
    get {
      if case .int(let v)? = inner {return v}
      return 0
    }
    set {inner = .int(newValue)}
  }

  /// CQL types: float
  var float: Float {
    get {
      if case .float(let v)? = inner {return v}
      return 0
    }
    set {inner = .float(newValue)}
  }

  /// CQL types: double
  var double: Double {
    get {
      if case .double(let v)? = inner {return v}
      return 0
    }
    set {inner = .double(newValue)}
  }

  /// CQL types: boolean
  var boolean: Bool {
    get {
      if case .boolean(let v)? = inner {return v}
      return false
    }
    set {inner = .boolean(newValue)}
  }

  /// CQL types: ascii, varchar, text
  var string: String {
    get {
      if case .string(let v)? = inner {return v}
      return String()
    }
    set {inner = .string(newValue)}
  }

  /// CQL types: blob, custom
  var bytes: Data {
    get {
      if case .bytes(let v)? = inner {return v}
      return Data()
    }
    set {inner = .bytes(newValue)}
  }

  /// CQL types: inet
  var inet: Stargate_Inet {
    get {
      if case .inet(let v)? = inner {return v}
      return Stargate_Inet()
    }
    set {inner = .inet(newValue)}
  }

  /// CQL types: uuid, timeuuid
  var uuid: Stargate_Uuid {
    get {
      if case .uuid(let v)? = inner {return v}
      return Stargate_Uuid()
    }
    set {inner = .uuid(newValue)}
  }

  /// CQL types: date
  /// An unsigned integer representing days with Unix epoch (January, 1 1970) at 2^31.
  /// Examples:
  /// 0:    -5877641-06-23
  /// 2^31: 1970-1-1
  /// 2^32: 5881580-07-11
  var date: UInt32 {
    get {
      if case .date(let v)? = inner {return v}
      return 0
    }
    set {inner = .date(newValue)}
  }

  /// CQL types: time
  /// An unsigned integer representing the number of nanoseconds since midnight. Valid values are
  /// in the range 0 to 86399999999999 (inclusive).
  var time: UInt64 {
    get {
      if case .time(let v)? = inner {return v}
      return 0
    }
    set {inner = .time(newValue)}
  }

  /// CQL types: list, set, map, tuple
  var collection: Stargate_Collection {
    get {
      if case .collection(let v)? = inner {return v}
      return Stargate_Collection()
    }
    set {inner = .collection(newValue)}
  }

  /// CQL types: user defined types
  var udt: Stargate_UdtValue {
    get {
      if case .udt(let v)? = inner {return v}
      return Stargate_UdtValue()
    }
    set {inner = .udt(newValue)}
  }

  /// CQL types: varint
  var varint: Stargate_Varint {
    get {
      if case .varint(let v)? = inner {return v}
      return Stargate_Varint()
    }
    set {inner = .varint(newValue)}
  }

  /// CQL types: decimal
  var decimal: Stargate_Decimal {
    get {
      if case .decimal(let v)? = inner {return v}
      return Stargate_Decimal()
    }
    set {inner = .decimal(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Inner: Equatable, @unchecked Sendable {
    /// The CQL value NULL.
    case null(Stargate_Value.Null)
    /// An unset value.
    /// This can only be used for bind values in requests.
    case unset(Stargate_Value.Unset)
    /// CQL types: tinyint, smallint, int, bigint, counter, timestamp
    case int(Int64)
    /// CQL types: float
    case float(Float)
    /// CQL types: double
    case double(Double)
    /// CQL types: boolean
    case boolean(Bool)
    /// CQL types: ascii, varchar, text
    case string(String)
    /// CQL types: blob, custom
    case bytes(Data)
    /// CQL types: inet
    case inet(Stargate_Inet)
    /// CQL types: uuid, timeuuid
    case uuid(Stargate_Uuid)
    /// CQL types: date
    /// An unsigned integer representing days with Unix epoch (January, 1 1970) at 2^31.
    /// Examples:
    /// 0:    -5877641-06-23
    /// 2^31: 1970-1-1
    /// 2^32: 5881580-07-11
    case date(UInt32)
    /// CQL types: time
    /// An unsigned integer representing the number of nanoseconds since midnight. Valid values are
    /// in the range 0 to 86399999999999 (inclusive).
    case time(UInt64)
    /// CQL types: list, set, map, tuple
    case collection(Stargate_Collection)
    /// CQL types: user defined types
    case udt(Stargate_UdtValue)
    /// CQL types: varint
    case varint(Stargate_Varint)
    /// CQL types: decimal
    case decimal(Stargate_Decimal)

  }

  struct Null: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Unset: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// A single CQL query.
struct Stargate_Query: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The query string. It can contain anonymous placeholders identified by a question mark (?), or
  /// named placeholders prefixed by a column (:name).
  var cql: String = String()

  /// The values to fill the placeholders in the query string.
  var values: Stargate_Values {
    get {return _values ?? Stargate_Values()}
    set {_values = newValue}
  }
  /// Returns true if `values` has been explicitly set.
  var hasValues: Bool {return self._values != nil}
  /// Clears the value of `values`. Subsequent reads from it will return its default value.
  mutating func clearValues() {self._values = nil}

  /// The execution parameters for the query.
  var parameters: Stargate_QueryParameters {
    get {return _parameters ?? Stargate_QueryParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  mutating func clearParameters() {self._parameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _values: Stargate_Values? = nil
  fileprivate var _parameters: Stargate_QueryParameters? = nil
}

/// The values to bind to the placeholders in a query.
struct Stargate_Values: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The values.
  var values: [Stargate_Value] = []

  /// The value names, if the query uses named placeholders.
  var valueNames: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The execution parameters for a Query message.
struct Stargate_QueryParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The keyspace to use when schema element names in the query (tables, UDTs, functions) are not
  /// fully qualified.
  var keyspace: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _keyspace ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_keyspace = newValue}
  }
  /// Returns true if `keyspace` has been explicitly set.
  var hasKeyspace: Bool {return self._keyspace != nil}
  /// Clears the value of `keyspace`. Subsequent reads from it will return its default value.
  mutating func clearKeyspace() {self._keyspace = nil}

  /// The consistency level.
  /// If unset, it defaults to LOCAL_QUORUM.
  var consistency: Stargate_ConsistencyValue {
    get {return _consistency ?? Stargate_ConsistencyValue()}
    set {_consistency = newValue}
  }
  /// Returns true if `consistency` has been explicitly set.
  var hasConsistency: Bool {return self._consistency != nil}
  /// Clears the value of `consistency`. Subsequent reads from it will return its default value.
  mutating func clearConsistency() {self._consistency = nil}

  /// The maximum number of rows that will be returned in the response. If there are more results,
  /// the response will contain a paging state, and additional queries will be needed to retrieve
  /// subsequent pages.
  /// Note that this is only a suggestion, the server reserves the right to return slightly smaller
  /// or bigger pages.
  /// If unset, it defaults to 100.
  var pageSize: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _pageSize ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  mutating func clearPageSize() {self._pageSize = nil}

  /// A paging state that indicates where to resume iteration in the result set. This is used to
  /// retrieve the next page of data when the number of results exceeds the page size.
  /// This should be filled with the value returned by the previous response (see
  /// ResultSet.paging_state). It is an opaque binary string that is only intended to be collected,
  /// stored and reused; any attempt to modify its contents or reuse it with a different statement
  /// will yield unpredictable results.
  var pagingState: SwiftProtobuf.Google_Protobuf_BytesValue {
    get {return _pagingState ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
    set {_pagingState = newValue}
  }
  /// Returns true if `pagingState` has been explicitly set.
  var hasPagingState: Bool {return self._pagingState != nil}
  /// Clears the value of `pagingState`. Subsequent reads from it will return its default value.
  mutating func clearPagingState() {self._pagingState = nil}

  /// Whether the server should collect tracing information about the execution of the query.
  /// If this is set, then a Traces message will be included in the Response message.
  var tracing: Bool = false

  /// Whether to omit ResultSet.columns in the response.
  /// This can be used to optimize response size when the client already knows that information (for
  /// example when fetching multiple pages for the same query).
  var skipMetadata: Bool = false

  /// The query timestamp (in microseconds). This is used to order mutations on the server.
  /// If unset, the server will assign one based on the time it received the query.
  var timestamp: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// The serial consistency level (if the query is a lightweight transaction).
  /// If unset, it defaults to SERIAL.
  var serialConsistency: Stargate_ConsistencyValue {
    get {return _serialConsistency ?? Stargate_ConsistencyValue()}
    set {_serialConsistency = newValue}
  }
  /// Returns true if `serialConsistency` has been explicitly set.
  var hasSerialConsistency: Bool {return self._serialConsistency != nil}
  /// Clears the value of `serialConsistency`. Subsequent reads from it will return its default value.
  mutating func clearSerialConsistency() {self._serialConsistency = nil}

  /// Forces the current time for the query (for testing purposes).
  /// This affects TTL cell liveness in read queries and local deletion time for tombstones and TTL
  /// cells in update requests.
  var nowInSeconds: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _nowInSeconds ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_nowInSeconds = newValue}
  }
  /// Returns true if `nowInSeconds` has been explicitly set.
  var hasNowInSeconds: Bool {return self._nowInSeconds != nil}
  /// Clears the value of `nowInSeconds`. Subsequent reads from it will return its default value.
  mutating func clearNowInSeconds() {self._nowInSeconds = nil}

  /// The consistency level to use to retrieve the query trace (if tracing is set).
  /// If unset, it defaults to ONE.
  var tracingConsistency: Stargate_ConsistencyValue {
    get {return _tracingConsistency ?? Stargate_ConsistencyValue()}
    set {_tracingConsistency = newValue}
  }
  /// Returns true if `tracingConsistency` has been explicitly set.
  var hasTracingConsistency: Bool {return self._tracingConsistency != nil}
  /// Clears the value of `tracingConsistency`. Subsequent reads from it will return its default value.
  mutating func clearTracingConsistency() {self._tracingConsistency = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyspace: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _consistency: Stargate_ConsistencyValue? = nil
  fileprivate var _pageSize: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _pagingState: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _serialConsistency: Stargate_ConsistencyValue? = nil
  fileprivate var _nowInSeconds: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _tracingConsistency: Stargate_ConsistencyValue? = nil
}

/// A CQL column type.
struct Stargate_TypeSpec: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spec: OneOf_Spec? {
    get {return _storage._spec}
    set {_uniqueStorage()._spec = newValue}
  }

  var basic: Stargate_TypeSpec.Basic {
    get {
      if case .basic(let v)? = _storage._spec {return v}
      return .custom
    }
    set {_uniqueStorage()._spec = .basic(newValue)}
  }

  var map: Stargate_TypeSpec.Map {
    get {
      if case .map(let v)? = _storage._spec {return v}
      return Stargate_TypeSpec.Map()
    }
    set {_uniqueStorage()._spec = .map(newValue)}
  }

  var list: Stargate_TypeSpec.List {
    get {
      if case .list(let v)? = _storage._spec {return v}
      return Stargate_TypeSpec.List()
    }
    set {_uniqueStorage()._spec = .list(newValue)}
  }

  var set: Stargate_TypeSpec.Set {
    get {
      if case .set(let v)? = _storage._spec {return v}
      return Stargate_TypeSpec.Set()
    }
    set {_uniqueStorage()._spec = .set(newValue)}
  }

  var udt: Stargate_TypeSpec.Udt {
    get {
      if case .udt(let v)? = _storage._spec {return v}
      return Stargate_TypeSpec.Udt()
    }
    set {_uniqueStorage()._spec = .udt(newValue)}
  }

  var tuple: Stargate_TypeSpec.Tuple {
    get {
      if case .tuple(let v)? = _storage._spec {return v}
      return Stargate_TypeSpec.Tuple()
    }
    set {_uniqueStorage()._spec = .tuple(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Spec: Equatable, Sendable {
    case basic(Stargate_TypeSpec.Basic)
    case map(Stargate_TypeSpec.Map)
    case list(Stargate_TypeSpec.List)
    case set(Stargate_TypeSpec.Set)
    case udt(Stargate_TypeSpec.Udt)
    case tuple(Stargate_TypeSpec.Tuple)

  }

  /// A CQL primitive type.
  enum Basic: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case custom // = 0
    case ascii // = 1
    case bigint // = 2
    case blob // = 3
    case boolean // = 4
    case counter // = 5
    case decimal // = 6
    case double // = 7
    case float // = 8
    case int // = 9
    case text // = 10
    case timestamp // = 11
    case uuid // = 12
    case varchar // = 13
    case varint // = 14
    case timeuuid // = 15
    case inet // = 16
    case date // = 17
    case time // = 18
    case smallint // = 19
    case tinyint // = 20
    case UNRECOGNIZED(Int)

    init() {
      self = .custom
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .custom
      case 1: self = .ascii
      case 2: self = .bigint
      case 3: self = .blob
      case 4: self = .boolean
      case 5: self = .counter
      case 6: self = .decimal
      case 7: self = .double
      case 8: self = .float
      case 9: self = .int
      case 10: self = .text
      case 11: self = .timestamp
      case 12: self = .uuid
      case 13: self = .varchar
      case 14: self = .varint
      case 15: self = .timeuuid
      case 16: self = .inet
      case 17: self = .date
      case 18: self = .time
      case 19: self = .smallint
      case 20: self = .tinyint
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .custom: return 0
      case .ascii: return 1
      case .bigint: return 2
      case .blob: return 3
      case .boolean: return 4
      case .counter: return 5
      case .decimal: return 6
      case .double: return 7
      case .float: return 8
      case .int: return 9
      case .text: return 10
      case .timestamp: return 11
      case .uuid: return 12
      case .varchar: return 13
      case .varint: return 14
      case .timeuuid: return 15
      case .inet: return 16
      case .date: return 17
      case .time: return 18
      case .smallint: return 19
      case .tinyint: return 20
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Stargate_TypeSpec.Basic] = [
      .custom,
      .ascii,
      .bigint,
      .blob,
      .boolean,
      .counter,
      .decimal,
      .double,
      .float,
      .int,
      .text,
      .timestamp,
      .uuid,
      .varchar,
      .varint,
      .timeuuid,
      .inet,
      .date,
      .time,
      .smallint,
      .tinyint,
    ]

  }

  struct Map: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: Stargate_TypeSpec {
      get {return _storage._key ?? Stargate_TypeSpec()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {_uniqueStorage()._key = nil}

    var value: Stargate_TypeSpec {
      get {return _storage._value ?? Stargate_TypeSpec()}
      set {_uniqueStorage()._value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return _storage._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {_uniqueStorage()._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct List: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var element: Stargate_TypeSpec {
      get {return _storage._element ?? Stargate_TypeSpec()}
      set {_uniqueStorage()._element = newValue}
    }
    /// Returns true if `element` has been explicitly set.
    var hasElement: Bool {return _storage._element != nil}
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    mutating func clearElement() {_uniqueStorage()._element = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Set: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var element: Stargate_TypeSpec {
      get {return _storage._element ?? Stargate_TypeSpec()}
      set {_uniqueStorage()._element = newValue}
    }
    /// Returns true if `element` has been explicitly set.
    var hasElement: Bool {return _storage._element != nil}
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    mutating func clearElement() {_uniqueStorage()._element = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// A CQL User-Defined type: a collection of named fields.
  struct Udt: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fields: Dictionary<String,Stargate_TypeSpec> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A CQL tuple: a collection of anonymous fields.
  struct Tuple: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var elements: [Stargate_TypeSpec] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Metadata about a CQL column.
struct Stargate_ColumnSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The CQL type.
  var type: Stargate_TypeSpec {
    get {return _type ?? Stargate_TypeSpec()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// The name.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Stargate_TypeSpec? = nil
}

/// Tracing information, included in the Response when it was requested by the client (see
/// QueryParameters.tracing or BatchParameters.tracing)
struct Stargate_Traces: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A technical identifier for this trace.
  var id: String = String()

  /// The server-side duration of the query (in microseconds).
  var duration: Int64 = 0

  /// The server-side timestamp of the start of the query.
  var startedAt: Int64 = 0

  var events: [Stargate_Traces.Event] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An event in a query trace.
  struct Event: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Which activity the event corresponds to.
    var activity: String = String()

    /// Identifies the host having generated the event.
    var source: String = String()

    /// The number of microseconds elapsed on the source when this event occurred since the moment
    /// when the source started handling the query.
    var sourceElapsed: Int64 = 0

    /// The name of the server thread on which this event occurred.
    var thread: String = String()

    /// A technical identifier for the event.
    var eventID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// If a Query message is a DDL statement, this will be included in the Response to describe the
/// how the CQL schema was impacted.
struct Stargate_SchemaChange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nature of the change (created, updated or dropped).
  var changeType: Stargate_SchemaChange.TypeEnum = .created

  /// The type of schema object that was affected.
  var target: Stargate_SchemaChange.Target = .keyspace

  /// The name of the keyspace.
  var keyspace: String = String()

  /// If the target is a keyspace element (table, type, etc), its name.
  var name: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _name ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// If the target is a function or aggregate, the CQL types of the arguments.
  var argumentTypes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case created // = 0
    case updated // = 1
    case dropped // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .created
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .created
      case 1: self = .updated
      case 2: self = .dropped
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .created: return 0
      case .updated: return 1
      case .dropped: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Stargate_SchemaChange.TypeEnum] = [
      .created,
      .updated,
      .dropped,
    ]

  }

  enum Target: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case keyspace // = 0
    case table // = 1
    case type // = 2
    case function // = 3
    case aggregate // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .keyspace
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .keyspace
      case 1: self = .table
      case 2: self = .type
      case 3: self = .function
      case 4: self = .aggregate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .keyspace: return 0
      case .table: return 1
      case .type: return 2
      case .function: return 3
      case .aggregate: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Stargate_SchemaChange.Target] = [
      .keyspace,
      .table,
      .type,
      .function,
      .aggregate,
    ]

  }

  init() {}

  fileprivate var _name: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

/// The response to a Query or Batch message.
struct Stargate_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Stargate_Response.OneOf_Result? = nil

  /// The result data.
  var resultSet: Stargate_ResultSet {
    get {
      if case .resultSet(let v)? = result {return v}
      return Stargate_ResultSet()
    }
    set {result = .resultSet(newValue)}
  }

  /// How the query changed the CQL schema.
  var schemaChange: Stargate_SchemaChange {
    get {
      if case .schemaChange(let v)? = result {return v}
      return Stargate_SchemaChange()
    }
    set {result = .schemaChange(newValue)}
  }

  /// The server-side warnings for the query, if any.
  var warnings: [String] = []

  /// The tracing information, if it was requested for the query.
  var traces: Stargate_Traces {
    get {return _traces ?? Stargate_Traces()}
    set {_traces = newValue}
  }
  /// Returns true if `traces` has been explicitly set.
  var hasTraces: Bool {return self._traces != nil}
  /// Clears the value of `traces`. Subsequent reads from it will return its default value.
  mutating func clearTraces() {self._traces = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable, Sendable {
    /// The result data.
    case resultSet(Stargate_ResultSet)
    /// How the query changed the CQL schema.
    case schemaChange(Stargate_SchemaChange)

  }

  init() {}

  fileprivate var _traces: Stargate_Traces? = nil
}

/// Thrown when the coordinator knows there is not enough replicas alive to perform a query with the
/// requested consistency level.
struct Stargate_Unavailable: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The consistency level of the operation that failed.
  var consistency: Stargate_Consistency = .any

  /// The number of replica acknowledgements/responses required to perform the operation (with its
  /// required consistency level).
  var required: Int32 = 0

  /// The number of replicas that were known to be alive by the coordinator node when it tried to
  /// execute the operation.
  var alive: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A server-side timeout during a write query.
struct Stargate_WriteTimeout: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The consistency level of the operation that failed.
  var consistency: Stargate_Consistency = .any

  /// The number of replica that had acknowledged/responded to the operation before it failed.
  var received: Int32 = 0

  /// The minimum number of replica acknowledgements/responses that were required to fulfill the
  /// operation.
  var blockFor: Int32 = 0

  /// The type of the write for which a timeout was raised.
  var writeType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A server-side timeout during a read query.
struct Stargate_ReadTimeout: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The consistency level of the operation that failed.
  var consistency: Stargate_Consistency = .any

  /// The number of replica that had acknowledged/responded to the operation before it failed.
  var received: Int32 = 0

  /// The minimum number of replica acknowledgements/responses that were required to fulfill the
  /// operation.
  var blockFor: Int32 = 0

  /// Whether the actual data was amongst the received replica responses.
  /// During reads, Cassandra doesn't request data from every replica to minimize internal network
  /// traffic. Instead, some replicas are only asked for a checksum of the data. A read timeout may
  /// occur even if enough replicas have responded to fulfill the consistency level, if only checksum
  /// responses have been received. This field allows to detect that case.
  var dataPresent: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A non-timeout error during a read query.
/// This happens when some of the replicas that were contacted by the coordinator replied with an
/// error.
struct Stargate_ReadFailure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The consistency level of the operation that failed.
  var consistency: Stargate_Consistency = .any

  /// The number of replica that had acknowledged/responded to the operation before it failed.
  var received: Int32 = 0

  /// The minimum number of replica acknowledgements/responses that were required to fulfill the
  /// operation.
  var blockFor: Int32 = 0

  /// The number of replicas that experienced a failure while executing the request.
  var numFailures: Int32 = 0

  /// Whether the actual data was amongst the received replica responses.
  /// During reads, Cassandra doesn't request data from every replica to minimize internal network
  /// traffic. Instead, some replicas are only asked for a checksum of the data. A read timeout may
  /// occur even if enough replicas have responded to fulfill the consistency level, if only checksum
  /// responses have been received. This field allows to detect that case.
  var dataPresent: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An error during the execution of a CQL function.
struct Stargate_FunctionFailure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The keyspace containing the function.
  var keyspace: String = String()

  /// The name of the function.
  var function: String = String()

  /// The CQL types of the arguments of the function.
  var argTypes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A non-timeout error during a write query.
/// This happens when some of the replicas that were contacted by the coordinator replied with an
/// error.
struct Stargate_WriteFailure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The consistency level of the operation that failed.
  var consistency: Stargate_Consistency = .any

  /// The number of replica that had acknowledged/responded to the operation before it failed.
  var received: Int32 = 0

  /// The minimum number of replica acknowledgements/responses that were required to fulfill the
  /// operation.
  var blockFor: Int32 = 0

  /// The number of replicas that experienced a failure while executing the request.
  var numFailures: Int32 = 0

  /// The type of the write for which an error was raised.
  var writeType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Thrown when a query attempts to create a keyspace or table that already exists.
struct Stargate_AlreadyExists: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyspace: String = String()

  var table: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An exception occured due to a contended Compare And Set write/update.
/// The CAS operation was only partially completed and the operation may or may not get completed by
/// the contending CAS write or SERIAL/LOCAL_SERIAL read.
struct Stargate_CasWriteUnknown: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The consistency level of the operation that failed.
  var consistency: Stargate_Consistency = .any

  /// The number of replica that had acknowledged/responded to the operation before it failed.
  var received: Int32 = 0

  /// The minimum number of replica acknowledgements/responses that were required to fulfill the
  /// operation.
  var blockFor: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A single row in a result set.
struct Stargate_Row: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The values for the columns (in the same order as ResultSet.columns).
  var values: [Stargate_Value] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The data returned in response to a CQL query.
struct Stargate_ResultSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata about the columns that this result set contains.
  /// This may be omitted if explicitly requested by the client (see QueryParameters.skip_metadata
  /// and BatchParameters.skip_metadata).
  var columns: [Stargate_ColumnSpec] = []

  /// The rows of CQL data.
  var rows: [Stargate_Row] = []

  /// If there are more pages, a paging state that will allow the client to build a new query for the
  /// next page.
  var pagingState: SwiftProtobuf.Google_Protobuf_BytesValue {
    get {return _pagingState ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
    set {_pagingState = newValue}
  }
  /// Returns true if `pagingState` has been explicitly set.
  var hasPagingState: Bool {return self._pagingState != nil}
  /// Clears the value of `pagingState`. Subsequent reads from it will return its default value.
  mutating func clearPagingState() {self._pagingState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagingState: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
}

/// A query inside of a Batch message.
struct Stargate_BatchQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The query string. It can contain anonymous placeholders identified by a question mark (?), or
  /// named placeholders prefixed by a column (:name).
  var cql: String = String()

  /// The values to fill the placeholders in the query string.
  var values: Stargate_Values {
    get {return _values ?? Stargate_Values()}
    set {_values = newValue}
  }
  /// Returns true if `values` has been explicitly set.
  var hasValues: Bool {return self._values != nil}
  /// Clears the value of `values`. Subsequent reads from it will return its default value.
  mutating func clearValues() {self._values = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _values: Stargate_Values? = nil
}

/// The execution parameters for a Batch message.
struct Stargate_BatchParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The keyspace to use when schema element names in the queries (tables, UDTs, functions) are not
  /// fully qualified.
  var keyspace: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _keyspace ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_keyspace = newValue}
  }
  /// Returns true if `keyspace` has been explicitly set.
  var hasKeyspace: Bool {return self._keyspace != nil}
  /// Clears the value of `keyspace`. Subsequent reads from it will return its default value.
  mutating func clearKeyspace() {self._keyspace = nil}

  /// The consistency level.
  /// If unset, it defaults to LOCAL_QUORUM.
  var consistency: Stargate_ConsistencyValue {
    get {return _consistency ?? Stargate_ConsistencyValue()}
    set {_consistency = newValue}
  }
  /// Returns true if `consistency` has been explicitly set.
  var hasConsistency: Bool {return self._consistency != nil}
  /// Clears the value of `consistency`. Subsequent reads from it will return its default value.
  mutating func clearConsistency() {self._consistency = nil}

  /// Whether the server should collect tracing information about the execution of the query.
  /// If this is set, then a Traces message will be included in the Response message.
  var tracing: Bool = false

  /// The query timestamp (in microseconds). This is used to order mutations on the server.
  /// If unset, the server will assign one based on the time it received the batch.
  var timestamp: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// The serial consistency level (if the batch contains lightweight transactions).
  /// If unset, it defaults to SERIAL.
  var serialConsistency: Stargate_ConsistencyValue {
    get {return _serialConsistency ?? Stargate_ConsistencyValue()}
    set {_serialConsistency = newValue}
  }
  /// Returns true if `serialConsistency` has been explicitly set.
  var hasSerialConsistency: Bool {return self._serialConsistency != nil}
  /// Clears the value of `serialConsistency`. Subsequent reads from it will return its default value.
  mutating func clearSerialConsistency() {self._serialConsistency = nil}

  /// Forces the current time for the query (for testing purposes).
  /// This affects TTL cell liveness in read queries and local deletion time for tombstones and TTL
  /// cells in update requests.
  var nowInSeconds: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _nowInSeconds ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_nowInSeconds = newValue}
  }
  /// Returns true if `nowInSeconds` has been explicitly set.
  var hasNowInSeconds: Bool {return self._nowInSeconds != nil}
  /// Clears the value of `nowInSeconds`. Subsequent reads from it will return its default value.
  mutating func clearNowInSeconds() {self._nowInSeconds = nil}

  /// The consistency level to use to retrieve the query trace (if tracing is set).
  /// If unset, it defaults to ONE.
  var tracingConsistency: Stargate_ConsistencyValue {
    get {return _tracingConsistency ?? Stargate_ConsistencyValue()}
    set {_tracingConsistency = newValue}
  }
  /// Returns true if `tracingConsistency` has been explicitly set.
  var hasTracingConsistency: Bool {return self._tracingConsistency != nil}
  /// Clears the value of `tracingConsistency`. Subsequent reads from it will return its default value.
  mutating func clearTracingConsistency() {self._tracingConsistency = nil}

  /// Whether to omit ResultSet.columns in the response.
  /// This can be used to optimize response size when the client already knows that information.
  var skipMetadata: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyspace: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _consistency: Stargate_ConsistencyValue? = nil
  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _serialConsistency: Stargate_ConsistencyValue? = nil
  fileprivate var _nowInSeconds: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _tracingConsistency: Stargate_ConsistencyValue? = nil
}

/// A batch containing multiple CQL queries.
struct Stargate_Batch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of batch.
  var type: Stargate_Batch.TypeEnum = .logged

  /// The CQL queries with their values.
  var queries: [Stargate_BatchQuery] = []

  /// The execution parameters for the batch.
  var parameters: Stargate_BatchParameters {
    get {return _parameters ?? Stargate_BatchParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  mutating func clearParameters() {self._parameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// A logged batch: Cassandra will first write the batch to its distributed batch log to ensure
    /// the atomicity of the batch (atomicity meaning that if any statement in the batch succeeds,
    /// all will eventually succeed).
    case logged // = 0

    /// A batch that doesn't use Cassandra's distributed batch log. Such batch are not guaranteed to
    /// be atomic.
    case unlogged // = 1

    /// A counter batch. Note that such batch is the only type that can contain counter operations
    /// and it can only contain these.
    case counter // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .logged
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .logged
      case 1: self = .unlogged
      case 2: self = .counter
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .logged: return 0
      case .unlogged: return 1
      case .counter: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Stargate_Batch.TypeEnum] = [
      .logged,
      .unlogged,
      .counter,
    ]

  }

  init() {}

  fileprivate var _parameters: Stargate_BatchParameters? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stargate"

extension Stargate_Consistency: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANY"),
    1: .same(proto: "ONE"),
    2: .same(proto: "TWO"),
    3: .same(proto: "THREE"),
    4: .same(proto: "QUORUM"),
    5: .same(proto: "ALL"),
    6: .same(proto: "LOCAL_QUORUM"),
    7: .same(proto: "EACH_QUORUM"),
    8: .same(proto: "SERIAL"),
    9: .same(proto: "LOCAL_SERIAL"),
    10: .same(proto: "LOCAL_ONE"),
  ]
}

extension Stargate_ConsistencyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsistencyValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .any {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_ConsistencyValue, rhs: Stargate_ConsistencyValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Collection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Collection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Collection, rhs: Stargate_Collection) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_UdtValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UdtValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Stargate_Value>.self, value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Stargate_Value>.self, value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_UdtValue, rhs: Stargate_UdtValue) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Uuid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Uuid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Uuid, rhs: Stargate_Uuid) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Inet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Inet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Inet, rhs: Stargate_Inet) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Varint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Varint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Varint, rhs: Stargate_Varint) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Decimal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Decimal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scale"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.scale) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scale != 0 {
      try visitor.visitSingularUInt32Field(value: self.scale, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Decimal, rhs: Stargate_Decimal) -> Bool {
    if lhs.scale != rhs.scale {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "null"),
    2: .same(proto: "unset"),
    3: .same(proto: "int"),
    4: .same(proto: "float"),
    5: .same(proto: "double"),
    6: .same(proto: "boolean"),
    7: .same(proto: "string"),
    8: .same(proto: "bytes"),
    9: .same(proto: "inet"),
    10: .same(proto: "uuid"),
    11: .same(proto: "date"),
    12: .same(proto: "time"),
    13: .same(proto: "collection"),
    14: .same(proto: "udt"),
    15: .same(proto: "varint"),
    16: .same(proto: "decimal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Stargate_Value.Null?
        var hadOneofValue = false
        if let current = self.inner {
          hadOneofValue = true
          if case .null(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inner = .null(v)
        }
      }()
      case 2: try {
        var v: Stargate_Value.Unset?
        var hadOneofValue = false
        if let current = self.inner {
          hadOneofValue = true
          if case .unset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inner = .unset(v)
        }
      }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularSInt64Field(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .int(v)
        }
      }()
      case 4: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .float(v)
        }
      }()
      case 5: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .double(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .boolean(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .string(v)
        }
      }()
      case 8: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .bytes(v)
        }
      }()
      case 9: try {
        var v: Stargate_Inet?
        var hadOneofValue = false
        if let current = self.inner {
          hadOneofValue = true
          if case .inet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inner = .inet(v)
        }
      }()
      case 10: try {
        var v: Stargate_Uuid?
        var hadOneofValue = false
        if let current = self.inner {
          hadOneofValue = true
          if case .uuid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inner = .uuid(v)
        }
      }()
      case 11: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .date(v)
        }
      }()
      case 12: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .time(v)
        }
      }()
      case 13: try {
        var v: Stargate_Collection?
        var hadOneofValue = false
        if let current = self.inner {
          hadOneofValue = true
          if case .collection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inner = .collection(v)
        }
      }()
      case 14: try {
        var v: Stargate_UdtValue?
        var hadOneofValue = false
        if let current = self.inner {
          hadOneofValue = true
          if case .udt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inner = .udt(v)
        }
      }()
      case 15: try {
        var v: Stargate_Varint?
        var hadOneofValue = false
        if let current = self.inner {
          hadOneofValue = true
          if case .varint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inner = .varint(v)
        }
      }()
      case 16: try {
        var v: Stargate_Decimal?
        var hadOneofValue = false
        if let current = self.inner {
          hadOneofValue = true
          if case .decimal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.inner = .decimal(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.inner {
    case .null?: try {
      guard case .null(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unset?: try {
      guard case .unset(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .int?: try {
      guard case .int(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 3)
    }()
    case .float?: try {
      guard case .float(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    }()
    case .double?: try {
      guard case .double(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }()
    case .boolean?: try {
      guard case .boolean(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case .string?: try {
      guard case .string(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case .bytes?: try {
      guard case .bytes(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }()
    case .inet?: try {
      guard case .inet(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .uuid?: try {
      guard case .uuid(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .date?: try {
      guard case .date(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    }()
    case .time?: try {
      guard case .time(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
    }()
    case .collection?: try {
      guard case .collection(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .udt?: try {
      guard case .udt(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .varint?: try {
      guard case .varint(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .decimal?: try {
      guard case .decimal(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Value, rhs: Stargate_Value) -> Bool {
    if lhs.inner != rhs.inner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Value.Null: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Stargate_Value.protoMessageName + ".Null"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Value.Null, rhs: Stargate_Value.Null) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Value.Unset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Stargate_Value.protoMessageName + ".Unset"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Value.Unset, rhs: Stargate_Value.Unset) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Query"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cql"),
    2: .same(proto: "values"),
    3: .same(proto: "parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cql) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._values) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cql.isEmpty {
      try visitor.visitSingularStringField(value: self.cql, fieldNumber: 1)
    }
    try { if let v = self._values {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Query, rhs: Stargate_Query) -> Bool {
    if lhs.cql != rhs.cql {return false}
    if lhs._values != rhs._values {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Values: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Values"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .standard(proto: "value_names"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.valueNames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    if !self.valueNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.valueNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Values, rhs: Stargate_Values) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.valueNames != rhs.valueNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_QueryParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyspace"),
    2: .same(proto: "consistency"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "paging_state"),
    5: .same(proto: "tracing"),
    6: .standard(proto: "skip_metadata"),
    7: .same(proto: "timestamp"),
    8: .standard(proto: "serial_consistency"),
    9: .standard(proto: "now_in_seconds"),
    10: .standard(proto: "tracing_consistency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyspace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._consistency) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pageSize) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._pagingState) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.tracing) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.skipMetadata) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._serialConsistency) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._nowInSeconds) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._tracingConsistency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyspace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._consistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pageSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pagingState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.tracing != false {
      try visitor.visitSingularBoolField(value: self.tracing, fieldNumber: 5)
    }
    if self.skipMetadata != false {
      try visitor.visitSingularBoolField(value: self.skipMetadata, fieldNumber: 6)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._serialConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._nowInSeconds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._tracingConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_QueryParameters, rhs: Stargate_QueryParameters) -> Bool {
    if lhs._keyspace != rhs._keyspace {return false}
    if lhs._consistency != rhs._consistency {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs._pagingState != rhs._pagingState {return false}
    if lhs.tracing != rhs.tracing {return false}
    if lhs.skipMetadata != rhs.skipMetadata {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._serialConsistency != rhs._serialConsistency {return false}
    if lhs._nowInSeconds != rhs._nowInSeconds {return false}
    if lhs._tracingConsistency != rhs._tracingConsistency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_TypeSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypeSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "basic"),
    2: .same(proto: "map"),
    3: .same(proto: "list"),
    4: .same(proto: "set"),
    5: .same(proto: "udt"),
    6: .same(proto: "tuple"),
  ]

  fileprivate class _StorageClass {
    var _spec: Stargate_TypeSpec.OneOf_Spec?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Stargate_TypeSpec.Basic?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._spec != nil {try decoder.handleConflictingOneOf()}
            _storage._spec = .basic(v)
          }
        }()
        case 2: try {
          var v: Stargate_TypeSpec.Map?
          var hadOneofValue = false
          if let current = _storage._spec {
            hadOneofValue = true
            if case .map(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._spec = .map(v)
          }
        }()
        case 3: try {
          var v: Stargate_TypeSpec.List?
          var hadOneofValue = false
          if let current = _storage._spec {
            hadOneofValue = true
            if case .list(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._spec = .list(v)
          }
        }()
        case 4: try {
          var v: Stargate_TypeSpec.Set?
          var hadOneofValue = false
          if let current = _storage._spec {
            hadOneofValue = true
            if case .set(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._spec = .set(v)
          }
        }()
        case 5: try {
          var v: Stargate_TypeSpec.Udt?
          var hadOneofValue = false
          if let current = _storage._spec {
            hadOneofValue = true
            if case .udt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._spec = .udt(v)
          }
        }()
        case 6: try {
          var v: Stargate_TypeSpec.Tuple?
          var hadOneofValue = false
          if let current = _storage._spec {
            hadOneofValue = true
            if case .tuple(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._spec = .tuple(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._spec {
      case .basic?: try {
        guard case .basic(let v)? = _storage._spec else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }()
      case .map?: try {
        guard case .map(let v)? = _storage._spec else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .list?: try {
        guard case .list(let v)? = _storage._spec else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .set?: try {
        guard case .set(let v)? = _storage._spec else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .udt?: try {
        guard case .udt(let v)? = _storage._spec else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .tuple?: try {
        guard case .tuple(let v)? = _storage._spec else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_TypeSpec, rhs: Stargate_TypeSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_TypeSpec.Basic: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM"),
    1: .same(proto: "ASCII"),
    2: .same(proto: "BIGINT"),
    3: .same(proto: "BLOB"),
    4: .same(proto: "BOOLEAN"),
    5: .same(proto: "COUNTER"),
    6: .same(proto: "DECIMAL"),
    7: .same(proto: "DOUBLE"),
    8: .same(proto: "FLOAT"),
    9: .same(proto: "INT"),
    10: .same(proto: "TEXT"),
    11: .same(proto: "TIMESTAMP"),
    12: .same(proto: "UUID"),
    13: .same(proto: "VARCHAR"),
    14: .same(proto: "VARINT"),
    15: .same(proto: "TIMEUUID"),
    16: .same(proto: "INET"),
    17: .same(proto: "DATE"),
    18: .same(proto: "TIME"),
    19: .same(proto: "SMALLINT"),
    20: .same(proto: "TINYINT"),
  ]
}

extension Stargate_TypeSpec.Map: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Stargate_TypeSpec.protoMessageName + ".Map"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _key: Stargate_TypeSpec? = nil
    var _value: Stargate_TypeSpec? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_TypeSpec.Map, rhs: Stargate_TypeSpec.Map) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_TypeSpec.List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Stargate_TypeSpec.protoMessageName + ".List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
  ]

  fileprivate class _StorageClass {
    var _element: Stargate_TypeSpec? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _element = source._element
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._element) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._element {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_TypeSpec.List, rhs: Stargate_TypeSpec.List) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._element != rhs_storage._element {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_TypeSpec.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Stargate_TypeSpec.protoMessageName + ".Set"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
  ]

  fileprivate class _StorageClass {
    var _element: Stargate_TypeSpec? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _element = source._element
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._element) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._element {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_TypeSpec.Set, rhs: Stargate_TypeSpec.Set) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._element != rhs_storage._element {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_TypeSpec.Udt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Stargate_TypeSpec.protoMessageName + ".Udt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Stargate_TypeSpec>.self, value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Stargate_TypeSpec>.self, value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_TypeSpec.Udt, rhs: Stargate_TypeSpec.Udt) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_TypeSpec.Tuple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Stargate_TypeSpec.protoMessageName + ".Tuple"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_TypeSpec.Tuple, rhs: Stargate_TypeSpec.Tuple) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_ColumnSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_ColumnSpec, rhs: Stargate_ColumnSpec) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Traces: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Traces"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "duration"),
    3: .standard(proto: "started_at"),
    4: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startedAt) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 2)
    }
    if self.startedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.startedAt, fieldNumber: 3)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Traces, rhs: Stargate_Traces) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.startedAt != rhs.startedAt {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Traces.Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Stargate_Traces.protoMessageName + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "activity"),
    2: .same(proto: "source"),
    3: .standard(proto: "source_elapsed"),
    4: .same(proto: "thread"),
    5: .standard(proto: "event_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.activity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.sourceElapsed) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.thread) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.activity.isEmpty {
      try visitor.visitSingularStringField(value: self.activity, fieldNumber: 1)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 2)
    }
    if self.sourceElapsed != 0 {
      try visitor.visitSingularInt64Field(value: self.sourceElapsed, fieldNumber: 3)
    }
    if !self.thread.isEmpty {
      try visitor.visitSingularStringField(value: self.thread, fieldNumber: 4)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Traces.Event, rhs: Stargate_Traces.Event) -> Bool {
    if lhs.activity != rhs.activity {return false}
    if lhs.source != rhs.source {return false}
    if lhs.sourceElapsed != rhs.sourceElapsed {return false}
    if lhs.thread != rhs.thread {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_SchemaChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SchemaChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "change_type"),
    2: .same(proto: "target"),
    3: .same(proto: "keyspace"),
    4: .same(proto: "name"),
    5: .standard(proto: "argument_types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.changeType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.target) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyspace) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.argumentTypes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.changeType != .created {
      try visitor.visitSingularEnumField(value: self.changeType, fieldNumber: 1)
    }
    if self.target != .keyspace {
      try visitor.visitSingularEnumField(value: self.target, fieldNumber: 2)
    }
    if !self.keyspace.isEmpty {
      try visitor.visitSingularStringField(value: self.keyspace, fieldNumber: 3)
    }
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.argumentTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.argumentTypes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_SchemaChange, rhs: Stargate_SchemaChange) -> Bool {
    if lhs.changeType != rhs.changeType {return false}
    if lhs.target != rhs.target {return false}
    if lhs.keyspace != rhs.keyspace {return false}
    if lhs._name != rhs._name {return false}
    if lhs.argumentTypes != rhs.argumentTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_SchemaChange.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREATED"),
    1: .same(proto: "UPDATED"),
    2: .same(proto: "DROPPED"),
  ]
}

extension Stargate_SchemaChange.Target: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEYSPACE"),
    1: .same(proto: "TABLE"),
    2: .same(proto: "TYPE"),
    3: .same(proto: "FUNCTION"),
    4: .same(proto: "AGGREGATE"),
  ]
}

extension Stargate_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_set"),
    4: .standard(proto: "schema_change"),
    2: .same(proto: "warnings"),
    3: .same(proto: "traces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Stargate_ResultSet?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .resultSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .resultSet(v)
        }
      }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.warnings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._traces) }()
      case 4: try {
        var v: Stargate_SchemaChange?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .schemaChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .schemaChange(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .resultSet(let v)? = self.result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.warnings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.warnings, fieldNumber: 2)
    }
    try { if let v = self._traces {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if case .schemaChange(let v)? = self.result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Response, rhs: Stargate_Response) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs._traces != rhs._traces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Unavailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unavailable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consistency"),
    2: .same(proto: "required"),
    3: .same(proto: "alive"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.consistency) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.required) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.alive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consistency != .any {
      try visitor.visitSingularEnumField(value: self.consistency, fieldNumber: 1)
    }
    if self.required != 0 {
      try visitor.visitSingularInt32Field(value: self.required, fieldNumber: 2)
    }
    if self.alive != 0 {
      try visitor.visitSingularInt32Field(value: self.alive, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Unavailable, rhs: Stargate_Unavailable) -> Bool {
    if lhs.consistency != rhs.consistency {return false}
    if lhs.required != rhs.required {return false}
    if lhs.alive != rhs.alive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_WriteTimeout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteTimeout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consistency"),
    2: .same(proto: "received"),
    3: .standard(proto: "block_for"),
    4: .standard(proto: "write_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.consistency) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.received) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.blockFor) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.writeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consistency != .any {
      try visitor.visitSingularEnumField(value: self.consistency, fieldNumber: 1)
    }
    if self.received != 0 {
      try visitor.visitSingularInt32Field(value: self.received, fieldNumber: 2)
    }
    if self.blockFor != 0 {
      try visitor.visitSingularInt32Field(value: self.blockFor, fieldNumber: 3)
    }
    if !self.writeType.isEmpty {
      try visitor.visitSingularStringField(value: self.writeType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_WriteTimeout, rhs: Stargate_WriteTimeout) -> Bool {
    if lhs.consistency != rhs.consistency {return false}
    if lhs.received != rhs.received {return false}
    if lhs.blockFor != rhs.blockFor {return false}
    if lhs.writeType != rhs.writeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_ReadTimeout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadTimeout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consistency"),
    2: .same(proto: "received"),
    3: .standard(proto: "block_for"),
    4: .standard(proto: "data_present"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.consistency) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.received) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.blockFor) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.dataPresent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consistency != .any {
      try visitor.visitSingularEnumField(value: self.consistency, fieldNumber: 1)
    }
    if self.received != 0 {
      try visitor.visitSingularInt32Field(value: self.received, fieldNumber: 2)
    }
    if self.blockFor != 0 {
      try visitor.visitSingularInt32Field(value: self.blockFor, fieldNumber: 3)
    }
    if self.dataPresent != false {
      try visitor.visitSingularBoolField(value: self.dataPresent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_ReadTimeout, rhs: Stargate_ReadTimeout) -> Bool {
    if lhs.consistency != rhs.consistency {return false}
    if lhs.received != rhs.received {return false}
    if lhs.blockFor != rhs.blockFor {return false}
    if lhs.dataPresent != rhs.dataPresent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_ReadFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consistency"),
    2: .same(proto: "received"),
    3: .standard(proto: "block_for"),
    4: .standard(proto: "num_failures"),
    5: .standard(proto: "data_present"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.consistency) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.received) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.blockFor) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.numFailures) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.dataPresent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consistency != .any {
      try visitor.visitSingularEnumField(value: self.consistency, fieldNumber: 1)
    }
    if self.received != 0 {
      try visitor.visitSingularInt32Field(value: self.received, fieldNumber: 2)
    }
    if self.blockFor != 0 {
      try visitor.visitSingularInt32Field(value: self.blockFor, fieldNumber: 3)
    }
    if self.numFailures != 0 {
      try visitor.visitSingularInt32Field(value: self.numFailures, fieldNumber: 4)
    }
    if self.dataPresent != false {
      try visitor.visitSingularBoolField(value: self.dataPresent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_ReadFailure, rhs: Stargate_ReadFailure) -> Bool {
    if lhs.consistency != rhs.consistency {return false}
    if lhs.received != rhs.received {return false}
    if lhs.blockFor != rhs.blockFor {return false}
    if lhs.numFailures != rhs.numFailures {return false}
    if lhs.dataPresent != rhs.dataPresent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_FunctionFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyspace"),
    2: .same(proto: "function"),
    3: .standard(proto: "arg_types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyspace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.function) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.argTypes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyspace.isEmpty {
      try visitor.visitSingularStringField(value: self.keyspace, fieldNumber: 1)
    }
    if !self.function.isEmpty {
      try visitor.visitSingularStringField(value: self.function, fieldNumber: 2)
    }
    if !self.argTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.argTypes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_FunctionFailure, rhs: Stargate_FunctionFailure) -> Bool {
    if lhs.keyspace != rhs.keyspace {return false}
    if lhs.function != rhs.function {return false}
    if lhs.argTypes != rhs.argTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_WriteFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consistency"),
    2: .same(proto: "received"),
    3: .standard(proto: "block_for"),
    4: .standard(proto: "num_failures"),
    5: .standard(proto: "write_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.consistency) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.received) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.blockFor) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.numFailures) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.writeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consistency != .any {
      try visitor.visitSingularEnumField(value: self.consistency, fieldNumber: 1)
    }
    if self.received != 0 {
      try visitor.visitSingularInt32Field(value: self.received, fieldNumber: 2)
    }
    if self.blockFor != 0 {
      try visitor.visitSingularInt32Field(value: self.blockFor, fieldNumber: 3)
    }
    if self.numFailures != 0 {
      try visitor.visitSingularInt32Field(value: self.numFailures, fieldNumber: 4)
    }
    if !self.writeType.isEmpty {
      try visitor.visitSingularStringField(value: self.writeType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_WriteFailure, rhs: Stargate_WriteFailure) -> Bool {
    if lhs.consistency != rhs.consistency {return false}
    if lhs.received != rhs.received {return false}
    if lhs.blockFor != rhs.blockFor {return false}
    if lhs.numFailures != rhs.numFailures {return false}
    if lhs.writeType != rhs.writeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_AlreadyExists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlreadyExists"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyspace"),
    2: .same(proto: "table"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyspace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.table) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyspace.isEmpty {
      try visitor.visitSingularStringField(value: self.keyspace, fieldNumber: 1)
    }
    if !self.table.isEmpty {
      try visitor.visitSingularStringField(value: self.table, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_AlreadyExists, rhs: Stargate_AlreadyExists) -> Bool {
    if lhs.keyspace != rhs.keyspace {return false}
    if lhs.table != rhs.table {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_CasWriteUnknown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CasWriteUnknown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consistency"),
    2: .same(proto: "received"),
    3: .standard(proto: "block_for"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.consistency) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.received) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.blockFor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consistency != .any {
      try visitor.visitSingularEnumField(value: self.consistency, fieldNumber: 1)
    }
    if self.received != 0 {
      try visitor.visitSingularInt32Field(value: self.received, fieldNumber: 2)
    }
    if self.blockFor != 0 {
      try visitor.visitSingularInt32Field(value: self.blockFor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_CasWriteUnknown, rhs: Stargate_CasWriteUnknown) -> Bool {
    if lhs.consistency != rhs.consistency {return false}
    if lhs.received != rhs.received {return false}
    if lhs.blockFor != rhs.blockFor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Row: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Row"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Row, rhs: Stargate_Row) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_ResultSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResultSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "columns"),
    2: .same(proto: "rows"),
    3: .standard(proto: "paging_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.columns) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rows) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagingState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.columns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columns, fieldNumber: 1)
    }
    if !self.rows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rows, fieldNumber: 2)
    }
    try { if let v = self._pagingState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_ResultSet, rhs: Stargate_ResultSet) -> Bool {
    if lhs.columns != rhs.columns {return false}
    if lhs.rows != rhs.rows {return false}
    if lhs._pagingState != rhs._pagingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_BatchQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cql"),
    2: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cql) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cql.isEmpty {
      try visitor.visitSingularStringField(value: self.cql, fieldNumber: 1)
    }
    try { if let v = self._values {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_BatchQuery, rhs: Stargate_BatchQuery) -> Bool {
    if lhs.cql != rhs.cql {return false}
    if lhs._values != rhs._values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_BatchParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyspace"),
    2: .same(proto: "consistency"),
    3: .same(proto: "tracing"),
    4: .same(proto: "timestamp"),
    5: .standard(proto: "serial_consistency"),
    6: .standard(proto: "now_in_seconds"),
    7: .standard(proto: "tracing_consistency"),
    8: .standard(proto: "skip_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyspace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._consistency) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.tracing) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._serialConsistency) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._nowInSeconds) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._tracingConsistency) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.skipMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyspace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._consistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.tracing != false {
      try visitor.visitSingularBoolField(value: self.tracing, fieldNumber: 3)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._serialConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nowInSeconds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._tracingConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.skipMetadata != false {
      try visitor.visitSingularBoolField(value: self.skipMetadata, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_BatchParameters, rhs: Stargate_BatchParameters) -> Bool {
    if lhs._keyspace != rhs._keyspace {return false}
    if lhs._consistency != rhs._consistency {return false}
    if lhs.tracing != rhs.tracing {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._serialConsistency != rhs._serialConsistency {return false}
    if lhs._nowInSeconds != rhs._nowInSeconds {return false}
    if lhs._tracingConsistency != rhs._tracingConsistency {return false}
    if lhs.skipMetadata != rhs.skipMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Batch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Batch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "queries"),
    3: .same(proto: "parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .logged {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 2)
    }
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stargate_Batch, rhs: Stargate_Batch) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.queries != rhs.queries {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stargate_Batch.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOGGED"),
    1: .same(proto: "UNLOGGED"),
    2: .same(proto: "COUNTER"),
  ]
}
